# BEGIN BPS TAGGED BLOCK {{{
#
# COPYRIGHT:
#
# This software is Copyright (c) 1996-2010 Best Practical Solutions, LLC
#                                          <sales@bestpractical.com>
#
# (Except where explicitly superseded by other copyright notices)
#
#
# LICENSE:
#
# This work is made available to you under the terms of Version 2 of
# the GNU General Public License. A copy of that license should have
# been provided with this software, but in any event can be snarfed
# from www.gnu.org.
#
# This work is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301 or visit their web page on the internet at
# http://www.gnu.org/copyleft/gpl.html.
#
#
# CONTRIBUTION SUBMISSION POLICY:
#
# (The following paragraph is not intended to limit the rights granted
# to you to modify and distribute this software under the terms of
# the GNU General Public License and is only of importance to you if
# you choose to contribute your changes and enhancements to the
# community by submitting them to Best Practical Solutions, LLC.)
#
# By intentionally submitting any modifications, corrections or
# derivatives to this work, or any other work intended for use with
# Request Tracker, to Best Practical Solutions, LLC, you confirm that
# you are the copyright holder for those contributions and you grant
# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,
# royalty-free, perpetual, license to use, copy, create derivative
# works based on those contributions, and sublicense and distribute
# those contributions and any derivatives thereof.
#
# END BPS TAGGED BLOCK }}}
# Autogenerated by DBIx::SearchBuilder factory (by <jesse@bestpractical.com>)
# WARNING: THIS FILE IS AUTOGENERATED. ALL CHANGES TO THIS FILE WILL BE LOST.  
# 
# !! DO NOT EDIT THIS FILE !!
#


=head1 NAME

  RT::Articles -- Class Description
 
=head1 SYNOPSIS

  use RT::Articles

=head1 DESCRIPTION


=head1 METHODS

=cut

no warnings 'redefine';
package RT::Articles;

use RT::SearchBuilder;
use RT::Article;

use base qw(RT::SearchBuilder);


sub _Init {
    my $self = shift;
    $self->{'table'} = 'Articles';
    $self->{'primary_key'} = 'id';



  # By default, order by name
  $self->OrderBy( ALIAS => 'main',
                  FIELD => 'SortOrder',
                  ORDER => 'ASC');

    return ( $self->SUPER::_Init(@_) );
}


=item NewItem

Returns an empty new RT::Article item

=cut

sub NewItem {
    my $self = shift;
    return(RT::Article->new($self->CurrentUser));
}

sub Search {
    my $self     = shift;
    my %args     = @_;
    my $customfields = $args{CustomFields}
      || RT::CustomFields->new( $self->CurrentUser );
    my $dates = $args{Dates} || {};
    my $order_by = $args{OrderBy};
    if ( $args{'q'} ) {
        $self->Limit(
            FIELD           => 'Name',
            SUBCLAUSE       => 'NameOrSummary',
            OPERATOR        => 'LIKE',
            ENTRYAGGREGATOR => 'OR',
            CASESENSITIVE   => 0,
            VALUE           => $args{'q'}
        );
        $self->Limit(
            FIELD           => 'Summary',
            SUBCLAUSE       => 'NameOrSummary',
            OPERATOR        => 'LIKE',
            ENTRYAGGREGATOR => 'OR',
            CASESENSITIVE   => 0,
            VALUE           => $args{'q'}
        );
    }


    require Time::ParseDate;
    foreach my $date qw(Created< Created> LastUpdated< LastUpdated>) {
        next unless ( $args{$date} );
        my $seconds = Time::ParseDate::parsedate( $args{$date}, FUZZY => 1, PREFER_PAST => 1 );
        my $date_obj = RT::Date->new( $self->CurrentUser );
        $date_obj->Set( Format => 'unix', Value => $seconds );
        $dates->{$date} = $date_obj;

        if ( $date =~ /^(.*?)<$/i ) {
            $self->Limit(
                FIELD           => $1,
                OPERATOR        => "<=",
                ENTRYAGGREGATOR => "AND",
                VALUE           => $date_obj->ISO
            );
        }

        if ( $date =~ /^(.*?)>$/i ) {
            $self->Limit(
                FIELD           => $1,
                OPERATOR        => ">=",
                ENTRYAGGREGATOR => "AND",
                VALUE           => $date_obj->ISO
            );
        }

    }

    if ($RefersTo) {
        foreach my $link ( split( /\s+/, $RefersTo ) ) {
            next unless ($link);
            $self->LimitRefersTo($link);
        }
    }

    if ($ReferredToBy) {
        foreach my $link ( split( /\s+/, $ReferredToBy ) ) {
            next unless ($link);
            $self->LimitReferredToBy($link);
        }
    }

    if ( $args{'Topics'} ) {
        my @Topics =
          ( ref $args{'Topics'} eq 'ARRAY' )
          ? @{ $args{'Topics'} }
          : ( $args{'Topics'} );
        @Topics = map { split } @Topics;
        if ( $args{'ExpandTopics'} ) {
            my %topics;
            while (@Topics) {
                my $id = shift @Topics;
                next if $topics{$id};
                my $Topics =
                  RT::Topics->new( $self->CurrentUser );
                $Topics->Limit( FIELD => 'Parent', VALUE => $id );
                push @Topics, $_->Id while $_ = $Topics->Next;
                $topics{$id}++;
            }
            @Topics = keys %topics;
            $args{'Topics'} = \@Topics;
        }
        $self->LimitTopics(@Topics);
    }

    my %cfs;
    $customfields->LimitToLookupType(
        RT::Article->new( $self->CurrentUser )
          ->CustomFieldLookupType );
    if ( $ARGS{'Class'} ) {
        my @Classes =
          ( ref $ARGS{'Class'} eq 'ARRAY' )
          ? @{ $ARGS{'Class'} }
          : ( $ARGS{'Class'} );
        foreach my $class (@Classes) {
            $customfields->LimitToGlobalOrObjectId($class);
        }
    }
    else {
        $customfields->LimitToGlobalOrObjectId();
    }
    while ( my $cf = $customfields->Next ) {
        $cfs{ $cf->Name } = $cf->Id;
    }

    # reset the iterator because we use this to build the UI
    $customfields->GotoFirstItem;

    foreach my $field ( keys %cfs ) {

        my @MatchLike =
          ( ref $args{ $field . "~" } eq 'ARRAY' )
          ? @{ $args{ $field . "~" } }
          : ( $args{ $field . "~" } );
        my @NoMatchLike =
          ( ref $args{ $field . "!~" } eq 'ARRAY' )
          ? @{ $args{ $field . "!~" } }
          : ( $args{ $field . "!~" } );

        my @Match =
          ( ref $args{$field} eq 'ARRAY' )
          ? @{ $args{$field} }
          : ( $args{$field} );
        my @NoMatch =
          ( ref $args{ $field . "!" } eq 'ARRAY' )
          ? @{ $args{ $field . "!" } }
          : ( $args{ $field . "!" } );

        foreach my $val (@MatchLike) {
            next unless $val;
            push @Match, "~" . $val;
        }

        foreach my $val (@NoMatchLike) {
            next unless $val;
            push @NoMatch, "~" . $val;
        }

        foreach my $value (@Match) {
            next unless $value;
            my $op;
            if ( $value =~ /^~(.*)$/ ) {
                $value = "%$1%";
                $op    = 'LIKE';
            }
            else {
                $op = '=';
            }
            $self->LimitCustomField(
                FIELD           => $cfs{$field},
                VALUE           => $value,
                CASESENSITIVE   => 0,
                ENTRYAGGREGATOR => 'OR',
                OPERATOR        => $op
            );
        }
        foreach my $value (@NoMatch) {
            next unless $value;
            my $op;
            if ( $value =~ /^~(.*)$/ ) {
                $value = "%$1%";
                $op    = 'NOT LIKE';
            }
            else {
                $op = '!=';
            }
            $self->LimitCustomField(
                FIELD           => $cfs{$field},
                VALUE           => $value,
                CASESENSITIVE   => 0,
                ENTRYAGGREGATOR => 'OR',
                OPERATOR        => $op
            );
        }
    }

### Searches for any field

    if ( $args{'Article~'} ) {
        $self->LimitCustomField(
            VALUE           => $args{'Article~'},
            ENTRYAGGREGATOR => 'OR',
            OPERATOR        => 'LIKE',
            CASESENSITIVE   => 0,
            SUBCLAUSE       => 'SearchAll'
        );
        $self->Limit(
            SUBCLAUSE       => 'SearchAll',
            FIELD           => "Name",
            VALUE           => $args{'Article~'},
            ENTRYAGGREGATOR => 'OR',
            CASESENSITIVE   => 0,
            OPERATOR        => 'LIKE'
        );
        $self->Limit(
            SUBCLAUSE       => 'SearchAll',
            FIELD           => "Summary",
            VALUE           => $args{'Article~'},
            ENTRYAGGREGATOR => 'OR',
            CASESENSITIVE   => 0,
            OPERATOR        => 'LIKE'
        );
    }

    if ( $args{'Article!~'} ) {
        $self->LimitCustomField(
            VALUE         => $args{'Article!~'},
            OPERATOR      => 'NOT LIKE',
            CASESENSITIVE => 0,
            SUBCLAUSE     => 'SearchAll'
        );
        $self->Limit(
            SUBCLAUSE       => 'SearchAll',
            FIELD           => "Name",
            VALUE           => $args{'Article!~'},
            ENTRYAGGREGATOR => 'AND',
            CASESENSITIVE   => 0,
            OPERATOR        => 'NOT LIKE'
        );
        $self->Limit(
            SUBCLAUSE       => 'SearchAll',
            FIELD           => "Summary",
            VALUE           => $args{'Article!~'},
            ENTRYAGGREGATOR => 'AND',
            CASESENSITIVE   => 0,
            OPERATOR        => 'NOT LIKE'
        );
    }

    foreach my $field qw(Name Summary Class) {

        my @MatchLike =
          ( ref $args{ $field . "~" } eq 'ARRAY' )
          ? @{ $args{ $field . "~" } }
          : ( $args{ $field . "~" } );
        my @NoMatchLike =
          ( ref $args{ $field . "!~" } eq 'ARRAY' )
          ? @{ $args{ $field . "!~" } }
          : ( $args{ $field . "!~" } );

        my @Match =
          ( ref $args{$field} eq 'ARRAY' )
          ? @{ $args{$field} }
          : ( $args{$field} );
        my @NoMatch =
          ( ref $args{ $field . "!" } eq 'ARRAY' )
          ? @{ $args{ $field . "!" } }
          : ( $args{ $field . "!" } );

        foreach my $val (@MatchLike) {
            next unless $val;
            push @Match, "~" . $val;
        }

        foreach my $val (@NoMatchLike) {
            next unless $val;
            push @NoMatch, "~" . $val;
        }

        my $op;
        foreach my $value (@Match) {
            if ( $value && $value =~ /^~(.*)$/ ) {
                $value = "%$1%";
                $op    = 'LIKE';
            }
            else {
                $op = '=';
            }

            # preprocess Classes, so we can search on class
            if ( $field eq 'Class' && $value ) {
                my $class = RT::Class->new($RT::SystemUser);
                $class->Load($value);
                $value = $class->Id;
            }

            # now that we've pruned the value, get out if it's different.
            next unless $value;

            $self->Limit(
                SUBCLAUSE       => $field . 'Match',
                FIELD           => $field,
                OPERATOR        => $op,
                CASESENSITIVE   => 0,
                VALUE           => $value,
                ENTRYAGGREGATOR => 'OR'
            );

        }
        foreach my $value (@NoMatch) {

            # preprocess Classes, so we can search on class
            if ( $value && $value =~ /^~(.*)/ ) {
                $value = "%$1%";
                $op    = 'NOT LIKE';
            }
            else {
                $op = '!=';
            }
            if ( $field eq 'Class' ) {
                my $class = RT::Class->new($RT::SystemUser);
                $class->Load($value);
                $value = $class->Id;
            }

            # now that we've pruned the value, get out if it's different.
            next unless $value;

            $self->Limit(
                SUBCLAUSE       => $field . 'NoMatch',
                OPERATOR        => $op,
                VALUE           => $value,
                CASESENSITIVE   => 0,
                FIELD           => $field,
                ENTRYAGGREGATOR => 'AND'
            );

        }
    }

    if ($order_by && @$order_by) {
        if ( $order_by[0] && $order_by[0] =~ /\|/ ) {
            @OrderBy = split '|', @OrderBy;
            @Order   = split '|', @Order;
        }
        my @tmp =
          map { { FIELD => $order_by[$_], ORDER => $Order[$_] } } 0 .. $#OrderBy;
        $self->OrderByCols(@tmp);
    }

    return 1;
}

RT::Base->_ImportOverlays();

1;
