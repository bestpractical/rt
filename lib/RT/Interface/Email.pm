# BEGIN BPS TAGGED BLOCK {{{
#
# COPYRIGHT:
#
# This software is Copyright (c) 1996-2007 Best Practical Solutions, LLC
#                                          <jesse@bestpractical.com>
#
# (Except where explicitly superseded by other copyright notices)
#
#
# LICENSE:
#
# This work is made available to you under the terms of Version 2 of
# the GNU General Public License. A copy of that license should have
# been provided with this software, but in any event can be snarfed
# from www.gnu.org.
#
# This work is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301 or visit their web page on the internet at
# http://www.gnu.org/copyleft/gpl.html.
#
#
# CONTRIBUTION SUBMISSION POLICY:
#
# (The following paragraph is not intended to limit the rights granted
# to you to modify and distribute this software under the terms of
# the GNU General Public License and is only of importance to you if
# you choose to contribute your changes and enhancements to the
# community by submitting them to Best Practical Solutions, LLC.)
#
# By intentionally submitting any modifications, corrections or
# derivatives to this work, or any other work intended for use with
# Request Tracker, to Best Practical Solutions, LLC, you confirm that
# you are the copyright holder for those contributions and you grant
# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,
# royalty-free, perpetual, license to use, copy, create derivative
# works based on those contributions, and sublicense and distribute
# those contributions and any derivatives thereof.
#
# END BPS TAGGED BLOCK }}}
package RT::Interface::Email;

use strict;
use warnings;

use Email::Address;
use MIME::Entity;
use RT::EmailParser;
use File::Temp;
use UNIVERSAL::require;

BEGIN {
    use base 'Exporter';
    use vars qw ( @EXPORT_OK);

    # set the version for version checking
    our $VERSION = 2.0;

    # your exported package globals go here,
    # as well as any optionally exported functions
    @EXPORT_OK = qw(
        &create_user
        &get_message_content
        &check_for_loops
        &check_for_suspicious_sender
        &check_for_auto_generated
        &check_for_bounce
        &mail_error
        &parse_sender_address_from_head
        &parse_errors_to_address_from_head
        &parse_address_from_header
        &gateway);

}

=head1 name

  RT::Interface::Email - helper functions for parsing email sent to RT

=head1 SYNOPSIS

  use lib "!!RT_LIB_PATH!!";
  use lib "!!RT_ETC_PATH!!";

  use RT::Interface::Email  qw(gateway create_user);

=head1 description




=head1 METHODS

=head2 check_for_loops HEAD

Takes a HEAD object of L<MIME::Head> class and returns true if the
message's been sent by this RT instance. Uses "X-RT-Loop-Prevention"
field of the head for test.

=cut

sub check_for_loops {
    my $head = shift;

    # If this instance of RT sent it our, we don't want to take it in
    my $RTLoop = $head->get("X-RT-Loop-Prevention") || "";
    chomp($RTLoop);    # remove that newline
    if ( $RTLoop eq RT->config->get('rtname') ) {
        return 1;
    }

    # TODO: We might not trap the case where RT instance A sends a mail
    # to RT instance B which sends a mail to ...
    return undef;
}

=head2 check_for_suspicious_sender HEAD

Takes a HEAD object of L<MIME::Head> class and returns true if sender
is suspicious. Suspicious means mailer daemon.

See also L</parse_sender_address_from_head>.

=cut

sub check_for_suspicious_sender {
    my $head = shift;

    #if it's from a postmaster or mailer daemon, it's likely a bounce.

    #TODO: better algorithms needed here - there is no standards for
    #bounces, so it's very difficult to separate them from anything
    #else.  At the other hand, the Return-To address is only ment to be
    #used as an error channel, we might want to put up a separate
    #Return-To address which is treated differently.

    #TODO: search through the whole email and find the right Ticket ID.

    my ( $From, $junk ) = parse_sender_address_from_head($head);

    if (   ( $From =~ /^mailer-daemon\@/i )
        or ( $From =~ /^postmaster\@/i )
        or ( $From eq "" ) )
    {
        return (1);

    }

    return undef;
}

=head2 check_for_auto_generated HEAD

Takes a HEAD object of L<MIME::Head> class and returns true if message
is autogenerated. Checks 'Precedence' and 'X-FC-Machinegenerated'
fields of the head in tests.

=cut

sub check_for_auto_generated {
    my $head = shift;

    my $Precedence = $head->get("Precedence") || "";
    if ( $Precedence =~ /^(bulk|junk)/i ) {
        return (1);
    }

    # Per RFC3834, any Auto-Submitted header which is not "no" means
    # it is auto-generated.
    my $AutoSubmitted = $head->get("Auto-Submitted") || "";
    if ( length $AutoSubmitted and $AutoSubmitted ne "no" ) {
        return (1);
    }

    # First Class mailer uses this as a clue.
    my $FCJunk = $head->get("X-FC-Machinegenerated") || "";
    if ( $FCJunk =~ /^true/i ) {
        return (1);
    }

    return (0);
}

sub check_for_bounce {
    my $head = shift;

    my $ReturnPath = $head->get("Return-path") || "";
    return ( $ReturnPath =~ /<>/ );
}

=head2 mail_error PARAM HASH

Sends an error message. Takes a param hash:

=over 4

=item From - sender's address, by default is 'correspond_address';

=item To - recipient, by default is 'OwnerEmail';

=item Bcc - optional Bcc recipients;

=item subject - subject of the message, default is 'There has been an error';

=item explanation - main content of the error, default value is 'Unexplained error';

=item mime_obj - optional MIME entity that's attached to the error mail, as well we
add 'In-Reply-To' field to the error that points to this message.

=item Attach - optional text that attached to the error as 'message/rfc822' part.

=item log_level - log level under which we should write explanation message into the
log, by default we log it as errorical.

=back

=cut

sub mail_error {
    my %args = (
        To          => RT->config->get('OwnerEmail'),
        Bcc         => undef,
        From        => RT->config->get('CorrespondAddress'),
        subject     => 'There has been an error',
        explanation => 'Unexplained error',
        mime_obj    => undef,
        Attach      => undef,
        log_level   => 'error',
        @_
    );

    my $level = $args{'log_level'};
    Jifty->log->$level( $args{'explanation'} ) if Jifty->log->can($level);

    # the colons are necessary to make ->build include non-standard headers
    my $entity = MIME::Entity->build(
        Type                    => "multipart/mixed",
        From                    => $args{'From'},
        Bcc                     => $args{'Bcc'},
        To                      => $args{'To'},
        Subject                 => $args{'subject'},
        'Precedence:'           => 'bulk',
        'X-RT-Loop-Prevention:' => RT->config->get('rtname'),
    );
    set_in_reply_to( Message => $entity, in_reply_to => $args{'mime_obj'} );

    $entity->attach( Data => $args{'explanation'} . "\n" );

    if ( $args{'mime_obj'} ) {
        $args{'mime_obj'}->sync_headers;
        $entity->add_part( $args{'mime_obj'} );
    }

    if ( $args{'Attach'} ) {
        $entity->attach( Data => $args{'Attach'}, Type => 'message/rfc822' );

    }

    send_email( entity => $entity, bounce => 1 );
}

=head2 send_email entity => undef, [ bounce => 0, ticket => undef, transaction => undef ]

Sends an email (passed as a L<MIME::Entity> object C<ENTITY>) using
RT's outgoing mail configuration. If C<BOUNCE> is passed, and is a
true value, the message will be marked as an autogenerated error, if
possible. Sets date field of the head to now if it's not set.

Ticket and transaction arguments are optional. If transaction is
specified and ticket is not then ticket of the transaction is
used, but only if the transaction belongs to a ticket.

Returns 1 on success, 0 on error or -1 if message has no recipients
and hasn't been sent.

=head3 Signing and Encrypting

This function as well signs and/or encrypts the message according to
headers of a transaction's attachment or properties of a ticket's queue.
To get full access to the configuration ticket and/or transaction
arguments must be provided, but you can force behaviour using Sign
and/or encrypt arguments.

The following precedence of arguments are used to figure out if
the message should be encrypted and/or signed:

* if sign or encrypt argument is defined then its value is used

* else if transaction's first attachment has X-RT-Sign or X-RT-Encrypt
header field then it's value is used

* else properties of a queue of the ticket are used.

=cut

sub send_email {
    my (%args) = (
        entity      => undef,
        bounce      => 0,
        ticket      => undef,
        transaction => undef,
        @_,
    );

    unless ( $args{'entity'} ) {
        Jifty->log->fatal("Could not send mail without 'entity' object");
        return 0;
    }

    my $msgid = $args{'entity'}->head->get('Message-ID') || '';
    chomp $msgid;

    # If we don't have any recipients to send to, don't send a message;
    unless ( $args{'entity'}->head->get('To')
        || $args{'entity'}->head->get('Cc')
        || $args{'entity'}->head->get('Bcc') )
    {
        Jifty->log->info( $msgid . " No recipients found. Not sending." );
        return -1;
    }

    if (   $args{'transaction'}
        && !$args{'ticket'}
        && $args{'transaction'}->object_type eq 'RT::Model::Ticket' )
    {
        $args{'ticket'} = $args{'transaction'}->object;
    }

    if ( RT->config->get('GnuPG')->{'enable'} ) {
        my %crypt;

        my $attachment;
        $attachment = $args{'transaction'}->attachments->first
            if $args{'transaction'};

        foreach my $argument (qw(sign encrypt)) {
            next if defined $args{$argument};

            if ( $attachment
                && defined $attachment->get_header("X-RT-$argument") )
            {
                $crypt{$argument} = $attachment->get_header("X-RT-$argument");
            } elsif ( $args{'ticket'} ) {
                $crypt{$argument} = $args{'ticket'}->queue_obj->$argument();
            }
        }

        my $res = sign_encrypt( %args, %crypt );
        return $res unless $res > 0;
    }

    unless ( $args{'entity'}->head->get('date') ) {
        require RT::Date;
        my $date = RT::Date->new( current_user => RT->system_user );
        $date->set_to_now;
        $args{'entity'}->head->set( 'date', $date->rfc2822( timezone => 'server' ) );
    }

    my $mail_command = RT->config->get('MailCommand');

    # if it is a sub routine, we just return it;
    return $mail_command->( $args{'entity'} )
        if UNIVERSAL::isa( $mail_command, 'CODE' );

    if ( $mail_command eq 'sendmailpipe' ) {
        my $path = RT->config->get('SendmailPath');
        my $args = RT->config->get('SendmailArguments');
        $args .= ' ' . RT->config->get('SendmailBounceArguments')
            if $args{'bounce'};

        # VERP
        if (    $args{'transaction'}
            and my $prefix = RT->config->get('VERPPrefix')
            and my $domain = RT->config->get('VERPDomain') )
        {
            my $from = $args{'transaction'}->creator_obj->email;
            $from =~ s/@/=/g;
            $from =~ s/\s//g;
            $args .= " -f $prefix$from\@$domain";
        }

        eval {

            # don't ignore CHLD signal to get proper exit code
            local $SIG{'CHLD'} = 'DEFAULT';

            open my $mail, "|$path $args"
                or die "couldn't execute program: $!";

            # if something wrong with $mail->print we will get PIPE signal, handle it
            local $SIG{'PIPE'} = sub { die "program unexpectedly closed pipe" };
            $args{'entity'}->print($mail);

            unless ( close $mail ) {
                die "close pipe failed: $!" if $!;    # system error
                                                      # sendmail exit statuses mostly errors with data not software
                                                      # TODO: status parsing: core dump, exit on signal or EX_*
                my $msg = "$msgid: `$path $args` exitted with code " . ( $? >> 8 );
                $msg = ", interrupted by signal " . ( $? & 127 ) if $? & 127;
                Jifty->log->error($msg);
            }
        };
        if ($@) {
            Jifty->log->fatal( "$msgid: Could not send mail with command `$path $args`: " . $@ );
            return 0;
        }
    } elsif ( $mail_command eq 'smtp' ) {
        require Net::SMTP;
        my $smtp = do {
            local $@;
            eval { Net::SMTP->new( Host => RT->config->get('SMTPServer'), Debug => RT->config->get('SMTPDebug'), ); };
        };
        unless ($smtp) {
            Jifty->log->fatal("Could not connect to SMTP server.");
            return 0;
        }

        # duplicate head as we want drop Bcc field
        my $head = $args{'entity'}->head->dup;
        my @recipients = map $_->address, Email::Address->parse( map $head->get($_), qw(To Cc Bcc) );
        $head->delete('Bcc');

        my $sender = RT->config->get('SMTPFrom')
            || $args{'entity'}->head->get('From');
        chomp $sender;

        my $status = $smtp->mail($sender)
            && $smtp->recipient(@recipients);

        if ($status) {
            $smtp->data;
            my $fh = $smtp->tied_fh;
            $head->print($fh);
            print $fh "\n";
            $args{'entity'}->print_body($fh);
            $smtp->dataend;
        }
        $smtp->quit;

        unless ($status) {
            Jifty->log->fatal("$msgid: Could not send mail via SMTP.");
            return 0;
        }
    } else {
        local ( $ENV{'MAILADDRESS'}, $ENV{'PERL_MAILERS'} );

        my @mailer_args = ($mail_command);
        if ( $mail_command eq 'sendmail' ) {
            $ENV{'PERL_MAILERS'} = RT->config->get('SendmailPath');
            push @mailer_args, split( /\s+/, RT->config->get('SendmailArguments') );
        } else {
            push @mailer_args, RT->config->get('MailParams');
        }

        unless ( $args{'entity'}->send(@mailer_args) ) {
            Jifty->log->fatal("$msgid: Could not send mail.");
            return 0;
        }
    }
    return 1;
}

=head2 prepare_email_using_template template => '', arguments => {}

Loads a template. Parses it using arguments if it's not empty.
Returns a tuple (L<RT::Model::Template> object, error message).

Note that even if a template object is returned mime_obj method
may return undef for empty templates.

=cut

sub prepare_email_using_template {
    my %args = (
        template  => '',
        arguments => {},
        @_
    );

    my $template = RT::Model::Template->new( current_user => RT->system_user );
    $template->load_global_template( $args{'template'} );
    unless ( $template->id ) {
        return ( undef, "Couldn't load template '" . $args{'template'} . "'" );
    }
    return $template if $template->is_empty;

    my ( $status, $msg ) = $template->parse( %{ $args{'arguments'} } );
    return ( undef, $msg ) unless $status;

    return $template;
}

=head2 send_email_using_template template => '', arguments => {}, From => correspond_address, To => '', Cc => '', Bcc => ''

Sends email using a template, takes name of template, arguments for it and recipients.

=cut

sub send_email_using_template {
    my %args = (
        template    => '',
        arguments   => {},
        to          => undef,
        cc          => undef,
        bcc         => undef,
        from        => RT->config->get('CorrespondAddress'),
        in_reply_to => undef,
        @_
    );

    my ( $template, $msg ) = prepare_email_using_template(%args);
    return ( 0, $msg ) unless $template;

    my $mail = $template->mime_obj;
    unless ($mail) {
        Jifty->log->info( "Message is not sent as template #" . $template->id . " is empty" );
        return -1;
    }

    $mail->head->set( $_ => $args{$_} ) foreach grep defined $args{$_}, qw(To Cc Bcc From);

    set_in_reply_to( message => $mail, in_reply_to => $args{'in_reply_to'} );

    return send_email( entity => $mail );
}

=head2 forward_transaction TRANSACTION, To => '', Cc => '', Bcc => ''

Forwards transaction with all attachments 'message/rfc822'.

=cut

sub forward_transaction {
    my $txn = shift;
    my %args = ( To => '', Cc => '', Bcc => '', @_ );

    my $main_content = $txn->content_obj;
    my $entity       = $main_content->content_as_mime;

    if ( $main_content->parent ) {

        # main content is not top most entity, we shouldn't loose
        # From/To/Cc headers that are on a top part
        my $attachments = RT::Model::AttachmentCollection->new( current_user => $txn->current_user );
        $attachments->query_columns(qw(id parent transaction_id headers));
        $attachments->limit( column => 'transaction_id', value => $txn->id );
        $attachments->limit( column => 'parent',         value => 0 );
        $attachments->limit(
            column      => 'parent',
            operator    => 'IS',
            value       => 'NULL',
            quote_value => 0
        );
        $attachments->order_by( column => 'id', order => 'ASC' );
        my $tmp = $attachments->first;

        if ( $tmp && $tmp->id ne $main_content->id ) {
            $entity->make_multipart;
            $entity->head->add( split /:/, $_, 2 ) foreach $tmp->split_headers;
            $entity->make_singlepart;
        }
    }

    my $attachments = RT::Model::AttachmentCollection->new( current_user => $txn->current_user );
    $attachments->limit( column => 'transaction_id', value => $txn->id );
    $attachments->limit(
        column   => 'id',
        operator => '!=',
        value    => $main_content->id,
    );
    $attachments->limit(
        column   => 'content_type',
        operator => 'NOT starts_with',
        value    => 'multipart/',
    );
    $attachments->limit(
        column   => 'content',
        operator => '!=',
        value    => '',
    );
    while ( my $a = $attachments->next ) {
        $entity->make_multipart unless $entity->is_multipart;
        $entity->add_part( $a->content_as_mime );
    }

    my ( $template, $msg ) = prepare_email_using_template(
        template  => 'Forward',
        arguments => {
            transaction => $txn,
            ticket      => $txn->object,
        },
    );
    my $mail;
    if ($template) {
        $mail = $template->mime_obj;
    } else {
        Jifty->log->warn($msg);
    }
    unless ($mail) {
        Jifty->log->warn("Couldn't generate email using template 'Forward'");

        my $description = 'This is forward of transaction #' . $txn->id . " of a ticket #" . $txn->object_id;
        $mail = MIME::Entity->build(
            Type => 'text/plain',
            Data => $description,
        );
    }

    $mail->head->set( $_ => $args{$_} ) foreach grep defined $args{$_}, qw(To Cc Bcc From);

    $mail->attach(
        Type        => 'message/rfc822',
        Disposition => 'attachment',
        description => 'forwarded message',
        Data        => $entity->as_string,
    );

    my $from;
    my $subject = $txn->subject || $txn->object->subject;
    if ( RT->config->get('ForwardFromUser') ) {
        $from = $txn->current_user->user_object->email;
    } else {

        # XXX: what if want to forward txn of other object than ticket?
        my $obj = $txn->object;
        $subject = add_subject_tag( $subject, $obj );
        $from = $obj->queue_obj->correspond_address
            || RT->config->get('CorrespondAddress');
    }
    $mail->head->set( subject => "Fwd: $subject" );
    $mail->head->set( From    => $from );

    my $status = RT->config->get('ForwardFromUser')

        # never sign if we forward from User
        ? send_email( entity => $mail, transaction => $txn, sign => 0 )
        : send_email( entity => $mail, transaction => $txn );
    return ( 0, $txn->_("Couldn't send email") ) unless $status;
    return ( 1, $txn->_("Send email successfully") );
}

=head2 sign_encrypt entity => undef, sign => 0, encrypt => 0

Signs and encrypts message using L<RT::Crypt::GnuPG>, but as well
handle errors with users' keys.

If a recipient has no key or has other problems with it, then the
unction sends a error to him using 'Error: public key' template.
Also, notifies RT's owner using template 'Error to RT owner: public key'
to inform that there are problems with users' keys. Then we filter
all bad recipients and retry.

Returns 1 on success, 0 on error and -1 if all recipients are bad and
had been filtered out.

=cut

sub sign_encrypt {
    my %args = (
        entity  => undef,
        sign    => 0,
        encrypt => 0,
        @_
    );
    return 1 unless $args{'sign'} || $args{'encrypt'};

    my $msgid = $args{'entity'}->head->get('Message-ID') || '';
    chomp $msgid;

    Jifty->log->debug("$msgid Signing message")    if $args{'sign'};
    Jifty->log->debug("$msgid Encrypting message") if $args{'encrypt'};

    require RT::Crypt::GnuPG;
    my %res = RT::Crypt::GnuPG::sign_encrypt(%args);
    return 1 unless $res{'exit_code'};

    my @status = RT::Crypt::GnuPG::parse_status( $res{'status'} );

    my @bad_recipients;
    foreach my $line (@status) {

        # if the passphrase fails, either you have a bad passphrase
        # or gpg-agent has died.  That should get caught in Create and
        # Update, but at least throw an error here
        if ( ( $line->{'Operation'} || '' ) eq 'PassphraseCheck' 
            && $line->{'Status'} =~ /^(?:BAD|MISSING)$/ )
        {
            Jifty->log->error("$line->{'Status'} PASSPHRASE: $line->{'message'}");
            return 0;
        }
        next unless ( $line->{'Operation'} || '' ) eq 'RecipientsCheck';
        next if $line->{'Status'} eq 'DONE';
        Jifty->log->error( $line->{'message'} );
        push @bad_recipients, $line;
    }
    return 0 unless @bad_recipients;

    $_->{'address_obj'} = ( Email::Address->parse( $_->{'Recipient'} ) )[0] foreach @bad_recipients;

    foreach my $recipient (@bad_recipients) {
        my $status = send_email_using_template(
            to        => $recipient->{'address_obj'}->address,
            template  => 'Error: public key',
            arguments => {
                %$recipient,
                ticket_obj      => $args{'ticket'},
                transaction_obj => $args{'transaction'},
            },
        );
        unless ($status) {
            Jifty->log->error("Couldn't send 'Error: public key'");
        }
    }

    my $status = send_email_using_template(
        to        => RT->config->get('OwnerEmail'),
        template  => 'Error to RT owner: public key',
        arguments => {
            bad_recipients  => \@bad_recipients,
            ticket_obj      => $args{'ticket'},
            transaction_obj => $args{'transaction'},
        },
    );
    unless ($status) {
        Jifty->log->error("Couldn't send 'Error to RT owner: public key'");
    }

    delete_recipients_from_head( $args{'entity'}->head, map $_->{'address_obj'}->address, @bad_recipients );

    unless ( $args{'entity'}->head->get('To')
        || $args{'entity'}->head->get('Cc')
        || $args{'entity'}->head->get('Bcc') )
    {
        Jifty->log->debug("$msgid No recipients that have public key, not sending");
        return -1;
    }

    # redo without broken recipients
    %res = RT::Crypt::GnuPG::sign_encrypt(%args);
    return 0 if $res{'exit_code'};

    return 1;
}

sub create_user {
    my ( $Username, $Address, $name, $errors_to, $entity ) = @_;

    my $NewUser = RT::Model::User->new( current_user => RT->system_user );

    my ( $Val, $Message ) = $NewUser->create(
        name => ( $Username || $Address ),
        email      => $Address,
        real_name  => $name,
        password   => undef,
        privileged => 0,
        comments   => 'AutoCreated on ticket submission',
    );

    unless ($Val) {

        # Deal with the race condition of two account creations at once
        if ($Username) {
            $NewUser->load_by_name($Username);
        }

        unless ( $NewUser->id ) {
            $NewUser->load_by_email($Address);
        }

        unless ( $NewUser->id ) {
            mail_error(
                to          => $errors_to,
                subject     => "User could not be Created",
                explanation => "User creation failed in mailgateway: $Message",
                mime_obj    => $entity,
                log_level   => 'error',
            );
        }
    }

    #Load the new user object
    my $CurrentUser = RT::CurrentUser->new( email => $Address );

    unless ( $CurrentUser->id ) {
        Jifty->log->warn( "Couldn't load user '$Address'." . "giving up" );
        mail_error(
            to          => $errors_to,
            subject     => "User could not be loaded",
            explanation => "User  '$Address' could not be loaded in the mail gateway",
            mime_obj    => $entity,
            log_level   => 'error'
        );
    }

    return $CurrentUser;
}

=head2 parse_cc->member_emails_as_string_from_head HASH

Takes a hash containing queue_obj, Head and current_user objects.
Returns a list of all email addresses in the To and Cc
headers b<except> the current Queue\'s email addresses, the CurrentUser\'s
email address  and anything that the configuration sub RT::is_rt_address matches.

=cut

sub parse_cc_addresses_from_head {
    my %args = (
        Head         => undef,
        queue_obj    => undef,
        current_user => undef,
        @_
    );

    my @recipients
        = map lc $_->address,
        map Email::Address->parse( $args{'Head'}->get($_) ), qw(To Cc);

    my @res;
    foreach my $address (@recipients) {
        $address = $args{'CurrentUser'}->user_object->canonicalize_email($address);
        next if lc $args{'CurrentUser'}->email            eq $address;
        next if lc $args{'queue_obj'}->correspond_address eq $address;
        next if lc $args{'queue_obj'}->comment_address    eq $address;
        next if RT::EmailParser->is_rt_address($address);

        push @res, $address;
    }
    return @res;
}

=head2 parse_sender_address_from_head HEAD

Takes a MIME::Header object. Returns a tuple: (user@host, friendly name)
of the From (evaluated in order of Reply-To:, From:, Sender)

=cut

sub parse_sender_address_from_head {
    my $head = shift;

    #Figure out who's sending this message.
    foreach my $header ( 'Reply-To', 'From', 'Sender' ) {
        my $addr_line = $head->get($header) || next;
        my ( $addr, $name ) = parse_address_from_header($addr_line);

        # only return if the address is not empty
        return ( $addr, $name ) if $addr;
    }

    return ( undef, undef );
}

=head2 parse_errors_to_address_from_head HEAD

Takes a MIME::Header object. Return a single value : user@host
of the From (evaluated in order of Return-path:,Errors-To:,Reply-To:,
From:, Sender)

=cut

sub parse_errors_to_address_from_head {
    my $head = shift;

    #Figure out who's sending this message.

    foreach my $header ( 'Errors-To', 'Reply-To', 'From', 'Sender' ) {

        # If there's a header of that name
        my $headerobj = $head->get($header);
        if ($headerobj) {
            my ( $addr, $name ) = parse_address_from_header($headerobj);

            # If it's got actual useful content...
            return ($addr) if ($addr);
        }
    }
}

=head2 parse_address_from_header ADDRESS

Takes an address from C<$head->get('Line')> and returns a tuple: user@host, friendly name

=cut

sub parse_address_from_header {
    my $Addr = shift;

    # Some broken mailers send:  ""Vincent, Jesse"" <jesse@fsck.com>. Hate
    $Addr =~ s/\"\"(.*?)\"\"/\"$1\"/g;
    my @Addresses = Email::Address->parse($Addr);

    my ($AddrObj) = grep ref $_, @Addresses;
    unless ($AddrObj) {
        return ( undef, undef );
    }

    my $name =
      (      $AddrObj->name
          || $AddrObj->phrase
          || $AddrObj->comment
          || $AddrObj->address );

    #Lets take the from and load a user object.
    my $Address = $AddrObj->address;

    return ( $Address, $name );
}

=head2 delete_recipients_from_head HEAD RECIPIENTS

Gets a head object and list of addresses.
Deletes addresses from To, Cc or Bcc fields.

=cut

sub delete_recipients_from_head {
    my $head = shift;
    my %skip = map { lc $_ => 1 } @_;

    foreach my $field (qw(To Cc Bcc)) {
        $head->set(
            $field => join ', ',
            map $_->format, grep !$skip{ lc $_->address },
            Email::Address->parse( $head->get($field) )
        );
    }
}

sub gen_message_id {
    my %args = (
        ticket       => undef,
        Scrip        => undef,
        scrip_action => undef,
        @_
    );
    my $org = RT->config->get('Organization');
    my $ticket_id = ( ref $args{'ticket'} ? $args{'ticket'}->id : $args{'ticket'} )
        || 0;
    my $scrip_id = ( ref $args{'Scrip'} ? $args{'Scrip'}->id : $args{'Scrip'} )
        || 0;
    my $sent = ( ref $args{'scrip_action'} ? $args{'scrip_action'}->{'_Message_ID'} : 0 )
        || 0;

    return "<rt-" . $RT::VERSION . "-" . $$ . "-" . CORE::time() . "-" . int( rand(2000) ) . '.' . $ticket_id . "-" . $scrip_id . "-" . $sent . "@" . $org . ">";
}

sub set_in_reply_to {
    my %args = (
        message     => undef,
        in_reply_to => undef,
        ticket      => undef,
        @_
    );
    return unless $args{'message'} && $args{'in_reply_to'};

    my $get_header = sub {
        my @res;
        if ( $args{'in_reply_to'}->isa('MIME::Entity') ) {
            @res = $args{'in_reply_to'}->head->get(shift);
        } else {
            @res = $args{'in_reply_to'}->get_header(shift) || '';
        }
        return grep length, map { split /\s+/m, $_ } grep defined, @res;
    };

    my @id         = $get_header->('Message-ID');
    my @rtid       = $get_header->('RT-Message-ID');
    my @references = $get_header->('References');
    unless (@references) {
        @references = $get_header->('In-Reply-To');
    }
    push @references, @id, @rtid;
    if ( $args{'ticket'} ) {
        my $pseudo_ref = '<RT-Ticket-' . $args{'ticket'}->id . '@' . RT->config->get('Organization') . '>';
        push @references, $pseudo_ref
            unless grep $_ eq $pseudo_ref, @references;
    }
    @references = splice @references, 4, -6
        if @references > 10;

    my $mail = $args{'message'};
    $mail->head->set( 'In-Reply-To' => join ' ', @rtid ? (@rtid) : (@id) )
        if @id || @rtid;
    $mail->head->set( 'References' => join ' ', @references );
}

sub parse_ticket_id {
    my $subject = shift;

    my $rtname    = RT->config->get('rtname');
    my $test_name = RT->config->get('EmailsubjectTagRegex')
        || qr/\Q$rtname\E/i;

    my $id;
    if ( $subject =~ s/\[$test_name\s+\#(\d+)\s*\]//i ) {
        $id = $1;
    }
    else {
        foreach my $tag ( RT->system->subject_tag ) {
            next unless $subject =~ s/\[\Q$tag\E\s+\#(\d+)\s*\]//i;
            $id = $1;
            last;
        }
    }
    return undef unless $id;

    Jifty->log->debug("Found a ticket ID. It's $id");
    return $id;
}

sub add_subject_tag {
    my $subject = shift;
    my $ticket  = shift;
    unless ( ref $ticket ) {
        my $tmp = RT::Model::Ticket->new( current_user => RT->system_user);
        $tmp->load($ticket->id);
        $ticket = $tmp;
    }
    my $id        = $ticket->id;
    my $queue_tag = $ticket->queue_obj->subject_tag;

    my $tag_re = RT->config->get('EmailSubjectTagRegex');
    unless ($tag_re) {
        my $tag = $queue_tag || RT->config->get('rtname');
        $tag_re = qr/\Q$tag\E/;
    }
    elsif ($queue_tag) {
        $tag_re = qr/$tag_re|\Q$queue_tag\E/;
        my $rtname = RT->config->get('rtname');
        $tag_re = qr/\Q$rtname\E/o;
    }
    return $subject if $subject =~ /\[$tag_re\s+#$id\]/;

    $subject =~ s/(\r\n|\n|\s)/ /gi;
    chomp $subject;
    return "["
      . ( $queue_tag || RT->config->get('rtname') )
      . " #$id] $subject";
}

=head2 gateway ARGSREF


Takes parameters:

    action
    queue
    message


This performs all the "guts" of the mail rt-mailgate program, and is
designed to be called from the web interface with a message, user
object, and so on.

Can also take an optional 'ticket' parameter; this ticket id overrides
any ticket id found in the subject.

Returns:

    An array of:

    (status code, message, optional ticket object)

    status code is a numeric value.

      for temporary failures, the status code should be -75

      for permanent failures which are handled by RT, the status code
      should be 0

      for succces, the status code should be 1



=cut

sub _load_plugins {
    my @mail_plugins = @_;

    my @res;
    foreach (@mail_plugins) {
        if ( ref($_) eq "CODE" ) {
            push @res, $_;
        } elsif ( !ref $_ ) {
            my $Class = $_;
            $Class = "RT::Interface::Email::" . $Class
                unless $Class =~ /^RT::Interface::Email::/;
            $Class->require
                or do { Jifty->log->error("Couldn't load $Class: $@"); next };

            no strict 'refs';
            unless ( defined *{ $Class . "::get_current_user" }{CODE} ) {
                Jifty->log->fatal("No get_current_user code found in $Class module");
                next;
            }
            push @res, $Class;
        } else {
            Jifty->log->fatal("$_ - is not class name or code reference");
        }
    }
    return @res;
}

sub gateway {
    my $argsref = shift;
    my %args    = (
        action  => 'correspond',
        queue   => '1',
        ticket  => undef,
        message => undef,
        %$argsref
    );

    my $SystemTicket;
    my $right;

    # Validate the action
    my ( $status, @actions ) = is_correct_action( $args{'action'} );
    unless ($status) {
        return ( -75, "Invalid 'action' parameter " . $actions[0] . " for queue " . $args{'queue'}, undef );
    }

    my $parser = RT::EmailParser->new();
    $parser->smart_parse_mime_entity_from_scalar(
        message => $args{'message'},
        decode  => 0,
        exact   => 1,
    );

    my $Message = $parser->entity();
    unless ($Message) {
        mail_error(
            subject     => "RT Bounce: Unparseable message",
            explanation => "RT couldn't process the message below",
            attach      => $args{'message'}
        );

        return ( 0, "Failed to parse this message. Something is likely badly wrong with the message" );
    }

    my @mail_plugins = grep $_, RT->config->get('MailPlugins');
    push @mail_plugins, "Auth::MailFrom" unless @mail_plugins;
    @mail_plugins = _load_plugins(@mail_plugins);

    my %skip_plugin;
    foreach my $class ( grep !ref, @mail_plugins ) {

        # check if we should apply filter before decoding
        my $check_cb = do {
            no strict 'refs';
            *{ $class . "::apply_before_decode" }{CODE};
        };
        next unless defined $check_cb;
        next
            unless $check_cb->(
            message         => $Message,
            raw_message_ref => \$args{'message'},
            );

        $skip_plugin{$class}++;

        my $Code = do {
            no strict 'refs';
            *{ $class . "::get_current_user" }{CODE};
        };
        my ( $status, $msg ) = $Code->(
            message         => $Message,
            raw_message_ref => \$args{'message'},
        );
        next if $status > 0;

        if ( $status == -2 ) {
            return ( 1, $msg, undef );
        } elsif ( $status == -1 ) {
            return ( 0, $msg, undef );
        }
    }
    @mail_plugins = grep !$skip_plugin{"$_"}, @mail_plugins;
    $parser->_decode_bodies;
    $parser->_post_process_new_entity;

    my $head      = $Message->head;
    my $errors_to = parse_errors_to_address_from_head($head);

    my $message_id = $head->get('Message-ID')
        || "<no-message-id-" . time . rand(2000) . '@' . RT->config->get('Organization') . '>';

    #Pull apart the subject line
    my $subject = $head->get('subject') || '';
    chomp $subject;

    # {{{ Lets check for mail loops of various sorts.
    my ( $should_store_machine_generated_message, $IsALoop, $result );
    ( $should_store_machine_generated_message, $errors_to, $result, $IsALoop ) = _handle_machine_generated_mail(
        message    => $Message,
        errors_to  => $errors_to,
        subject    => $subject,
        message_id => $message_id
    );

    # Do not pass loop messages to MailPlugins, to make sure the loop
    # is broken, unless $RT::StoreLoops is set.
    if ( $IsALoop && !$should_store_machine_generated_message ) {
        return ( 0, $result, undef );
    }

    $args{'ticket'} ||= parse_ticket_id($subject);

    $SystemTicket = RT::Model::Ticket->new( current_user => RT->system_user );
    $SystemTicket->load( $args{'ticket'} ) if ( $args{'ticket'} );
    if ( $SystemTicket->id ) {
        $right = 'ReplyToTicket';
    } else {
        $right = 'CreateTicket';
    }

    #Set up a queue object
    my $Systemqueue_obj = RT::Model::Queue->new( current_user => RT->system_user );
    $Systemqueue_obj->load( $args{'queue'} );

    # We can safely have no queue of we have a known-good ticket
    unless ( $SystemTicket->id || $Systemqueue_obj->id ) {
        return ( -75, "RT couldn't find the queue: " . $args{'queue'}, undef );
    }

    # Authentication Level ($AuthStat)
    # -1 - Get out.  this user has been explicitly declined
    # 0 - User may not do anything (Not used at the moment)
    # 1 - Normal user
    # 2 - User is allowed to specify status updates etc. a la enhanced-mailgate
    my ( $CurrentUser, $AuthStat, $error );

    # Initalize AuthStat so comparisons work correctly
    $AuthStat = -9999999;

    # if plugin returns AuthStat -2 we skip action
    # NOTE: this is experimental API and it would be changed
    my %skip_action = ();

    # Since this needs loading, no matter what
    foreach (@mail_plugins) {
        my ( $Code, $NewAuthStat );
        if ( ref($_) eq "CODE" ) {
            $Code = $_;
        } else {
            no strict 'refs';
            $Code = *{ $_ . "::get_current_user" }{CODE};
        }

        foreach my $action (@actions) {
            ( $CurrentUser, $NewAuthStat ) = $Code->(
                message         => $Message,
                raw_message_ref => \$args{'message'},
                current_user    => $CurrentUser,
                auth_level      => $AuthStat,
                action          => $action,
                ticket          => $SystemTicket,
                queue           => $Systemqueue_obj
            );

            # You get the highest level of authentication you were assigned, unless you get the magic -1
            # If a module returns a "-1" then we discard the ticket, so.
            $AuthStat = $NewAuthStat
                if ( $NewAuthStat > $AuthStat
                or $NewAuthStat == -1
                or $NewAuthStat == -2 );

            last if $AuthStat == -1;
            $skip_action{$action}++ if $AuthStat == -2;
        }

        # strip actions we should skip
        @actions = grep !$skip_action{$_}, @actions if $AuthStat == -2;
        last unless @actions;

        last if $AuthStat == -1;
    }

    # {{{ If authentication fails and no new user was Created, get out.
    if ( !$CurrentUser || !$CurrentUser->id || $AuthStat == -1 ) {

        # If the plugins refused to create one, they lose.
        unless ( $AuthStat == -1 ) {
            _no_authorized_user_found(
                right     => $right,
                message   => $Message,
                requestor => $errors_to,
                queue     => $args{'queue'}
            );

        }
        return ( 0, "Could not load a valid user", undef );
    }

    # If we got a user, but they don't have the right to say things
    if ( $AuthStat == 0 ) {
        mail_error(
            to          => $errors_to,
            subject     => "Permission Denied",
            explanation => "You do not have permission to communicate with RT",
            mime_obj    => $Message
        );
        return ( 0, "$errors_to tried to submit a message to " . $args{'queue'} . " without permission.", undef );
    }

    unless ($should_store_machine_generated_message) {
        return ( 0, $result, undef );
    }

    # if plugin's updated SystemTicket then update arguments
    $args{'ticket'} = $SystemTicket->id if $SystemTicket && $SystemTicket->id;

    my $ticket = RT::Model::Ticket->new( current_user => $CurrentUser );

    if ( !$args{'ticket'} && grep /^(comment|correspond)$/, @actions ) {

        my @Cc;
        my @requestors = ( $CurrentUser->id );

        if ( RT->config->get('ParseNewMessageForTicketCcs') ) {
            @Cc = parse_cc_addresses_from_head(
                head         => $head,
                current_user => $CurrentUser,
                queue_obj    => $Systemqueue_obj
            );
        }

        my ( $id, $transaction, $ErrStr ) = $ticket->create(
            queue     => $Systemqueue_obj->id,
            subject   => $subject,
            requestor => \@requestors,
            cc        => \@Cc,
            mime_obj  => $Message
        );
        if ( $id == 0 ) {
            mail_error(
                to          => $errors_to,
                subject     => "Ticket creation failed: $subject",
                explanation => $ErrStr,
                mime_obj    => $Message
            );
            return ( 0, "Ticket creation failed: $ErrStr", $ticket );
        }

        # strip comments&corresponds from the actions we don't need
        # to record them if we've Created the ticket just now
        @actions = grep !/^(comment|correspond)$/, @actions;
        $args{'ticket'} = $id;

    } elsif ( $args{'ticket'} ) {

        $ticket->load( $args{'ticket'} );
        unless ( $ticket->id ) {
            my $error = "Could not find a ticket with id " . $args{'ticket'};
            mail_error(
                to          => $errors_to,
                subject     => "Message not recorded: $subject",
                explanation => $error,
                mime_obj    => $Message
            );

            return ( 0, $error );
        }
        $args{'ticket'} = $ticket->id;
    } else {
        return ( 1, "Success", $ticket );
    }

    # }}}

    my $unsafe_actions = RT->config->get('UnsafeEmailCommands');
    foreach my $action (@actions) {

        #   If the action is comment, add a comment.
        if ( $action =~ /^(?:comment|correspond)$/i ) {
            my $method = lc $action;
            my ( $status, $msg ) = $ticket->$method( mime_obj => $Message );
            unless ($status) {

                #Warn the sender that we couldn't actually submit the comment.
                mail_error(
                    to          => $errors_to,
                    subject     => "Message not recorded: $subject",
                    explanation => $msg,
                    mime_obj    => $Message
                );
                return ( 0, "Message not recorded: $msg", $ticket );
            }
        } elsif ($unsafe_actions) {
            my ( $status, $msg ) = _run_unsafe_action(
                action       => $action,
                errors_to    => $errors_to,
                message      => $Message,
                ticket       => $ticket,
                current_user => $CurrentUser,
            );
            return ( $status, $msg, $ticket ) unless $status == 1;
        }
    }
    return ( 1, "Success", $ticket );
}

sub _run_unsafe_action {
    my %args = (
        action       => undef,
        errors_to    => undef,
        message      => undef,
        ticket       => undef,
        current_user => undef,
        @_
    );

    if ( $args{'action'} =~ /^take$/i ) {
        my ( $status, $msg ) = $args{'ticket'}->set_owner( $args{'CurrentUser'}->id );
        unless ($status) {
            mail_error(
                To          => $args{'errors_to'},
                subject     => "Ticket not taken",
                explanation => $msg,
                mime_obj    => $args{'message'}
            );
            return ( 0, "Ticket not taken" );
        }
    } elsif ( $args{'action'} =~ /^resolve$/i ) {
        my ( $status, $msg ) = $args{'ticket'}->set_status('resolved');
        unless ($status) {

            #Warn the sender that we couldn't actually submit the comment.
            mail_error(
                to          => $args{'errors_to'},
                subject     => "Ticket not resolved",
                explanation => $msg,
                mime_obj    => $args{'message'}
            );
            return ( 0, "Ticket not resolved" );
        }
    } else {
        return ( 0, "Not supported unsafe action $args{'action'}", $args{'ticket'} );
    }
    return ( 1, "Success" );
}

=head2 _no_authorized_user_found

Emails the RT Owner and the requestor when the auth plugins return "No auth user found"

=cut

sub _no_authorized_user_found {
    my %args = (
        right     => undef,
        message   => undef,
        requestor => undef,
        queue     => undef,
        @_
    );

    # Notify the RT Admin of the failure.
    mail_error(
        To          => RT->config->get('OwnerEmail'),
        subject     => "Could not load a valid user",
        explanation => <<EOT,
RT could not load a valid user, and RT's configuration does not allow
for the creation of a new user for this email (@{[$args{requestor}]}).

You might need to grant 'Everyone' the right '@{[$args{right}]}' for the
queue @{[$args{'queue'}]}.

EOT
        mime_obj  => $args{'message'},
        log_level => 'error'
    );

    # Also notify the requestor that his request has been dropped.
    if ( $args{'requestor'} ne RT->config->get('OwnerEmail') ) {
        mail_error(
            to          => $args{'requestor'},
            subject     => "Could not load a valid user",
            explanation => <<EOT,
RT could not load a valid user, and RT's configuration does not allow
for the creation of a new user for your email.

EOT
            mime_obj  => $args{'message'},
            log_level => 'error'
        );
    }
}

=head2 _handle_machine_generated_mail

Takes named params:
    Message
    errors_to
    subject

Checks the message to see if it's a bounce, if it looks like a loop, if it's autogenerated, etc.
Returns a triple of ("Should we continue (boolean)", "New value for $errors_to", "Status message",
"This message appears to be a loop (boolean)" );

=cut

sub _handle_machine_generated_mail {
    my %args = (
        message    => undef,
        errors_to  => undef,
        subject    => undef,
        message_id => undef,
        @_
    );
    my $head      = $args{'message'}->head;
    my $errors_to = $args{'errors_to'};

    my $IsBounce = check_for_bounce($head);

    my $IsAutoGenerated = check_for_auto_generated($head);

    my $IsSuspiciousSender = check_for_suspicious_sender($head);

    my $IsALoop = check_for_loops($head);

    my $SquelchReplies = 0;

    my $owner_mail = RT->config->get('OwnerEmail');

    #If the message is autogenerated, we need to know, so we can not
    # send mail to the sender
    if ( $IsBounce || $IsSuspiciousSender || $IsAutoGenerated || $IsALoop ) {
        $SquelchReplies = 1;
        $errors_to      = $owner_mail;
    }

    # Warn someone if it's a loop, before we drop it on the ground
    if ($IsALoop) {
        Jifty->log->fatal( "RT Received mail (" . $args{message_id} . ") from itself." );

        #Should we mail it to RTOwner?
        if ( RT->config->get('LoopsToRTOwner') ) {
            mail_error(
                to          => $owner_mail,
                subject     => "RT Bounce: " . $args{'subject'},
                explanation => "RT thinks this message may be a bounce",
                mime_obj    => $args{Message}
            );
        }

        #Do we actually want to store it?
        return ( 0, $errors_to, "Message Bounced", $IsALoop )
            unless RT->config->get('StoreLoops');
    }

    # Squelch replies if necessary
    # Don't let the user stuff the RT-Squelch-Replies-To header.
    if ( $head->get('RT-Squelch-Replies-To') ) {
        $head->add( 'RT-Relocated-Squelch-Replies-To', $head->get('RT-Squelch-Replies-To') );
        $head->delete('RT-Squelch-Replies-To');
    }

    if ($SquelchReplies) {

        # Squelch replies to the sender, and also leave a clue to
        # allow us to squelch ALL outbound messages. This way we
        # can punt the logic of "what to do when we get a bounce"
        # to the scrip. We might want to notify nobody. Or just
        # the RT Owner. Or maybe all privileged watchers.
        my ( $Sender, $junk ) = parse_sender_address_from_head($head);
        $head->add( 'RT-Squelch-Replies-To',    $Sender );
        $head->add( 'RT-DetectedAutoGenerated', 'true' );
    }
    return ( 1, $errors_to, "Handled machine detection", $IsALoop );
}

=head2 is_correct_action

Returns a list of valid actions we've found for this message

=cut

sub is_correct_action {
    my $action = shift;
    my @actions = grep $_, split /-/, $action;
    return ( 0, '(no value)' ) unless @actions;
    foreach (@actions) {
        return ( 0, $_ ) unless /^(?:comment|correspond|take|resolve)$/;
    }
    return ( 1, @actions );
}

1;
