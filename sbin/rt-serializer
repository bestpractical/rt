#!/usr/bin/perl -w
use strict;
use warnings;

use lib 'lib';
use RT;
RT::LoadConfig();
RT::Init();

use Getopt::Long;
use Time::HiRes qw//;

my %OPT;
GetOptions(
    \%OPT,

    "directory|d=s",
    "force!",
    "size|s=i",

    "users!",
    "groups!",
    "deleted!",

    "scrips!",
    "tickets!",
    "acls!",

    "gc=i",
);

my %args;
$args{Directory}   = $OPT{directory};
$args{Force}       = $OPT{force};
$args{MaxFileSize} = $OPT{size} if $OPT{size};

$args{AllUsers}      = $OPT{users}    if defined $OPT{users};
$args{AllGroups}     = $OPT{groups}   if defined $OPT{groups};
$args{FollowDeleted} = $OPT{deleted}  if defined $OPT{deleted};

$args{FollowScrips}  = $OPT{scrips}   if defined $OPT{scrips};
$args{FollowTickets} = $OPT{tickets}  if defined $OPT{tickets};
$args{FollowACL}     = $OPT{acls}     if defined $OPT{acls};

$args{GC} = defined $OPT{gc} ? $OPT{gc} : 5000;

my $gnuplot = `which gnuplot`;
my $msg = "";
if (-t STDOUT) {
    $args{Progress} = \&progress;
    $args{MessageHandler} = sub {
        print "\r", " "x60, "\r", $_[-1]; $msg = $_[-1];
    };
    $args{Verbose}  = 0;
}

use RT::Serializer;
my $walker = RT::Serializer->new( %args );

my %estimates = estimate();

print "Beginning database serialization...";
my %counts = $walker->Walk;

my @files = $walker->Files;
print "Wrote @{[scalar @files]} files:\n";
print "    $_\n" for @files;
print "\n";

print "Total object counts:\n";
for (sort {$counts{$b} <=> $counts{$a}} keys %counts) {
    printf "%8d %s\n", $counts{$_}, $_;
}



sub estimate {
    $| = 1;
    my %e;

    # Expected types we'll serialize
    my @types = qw/
                      RT::Queue
                      RT::Ticket
                      RT::Transaction
                      RT::Attachment
                      RT::Link

                      RT::User
                      RT::Group
                      RT::GroupMember

                      RT::Attribute

                      RT::CustomField
                      RT::CustomFieldValue
                      RT::ObjectCustomField
                      RT::ObjectCustomFieldValue
                  /;

    $e{total} = 0;
    for my $class (@types) {
        print "Estimating $class count...";
        my $collection = $class . "s";
        my $objs = $collection->new( RT->SystemUser );
        $objs->UnLimit;
        $objs->{allow_deleted_search} = 1 if $class eq "RT::Ticket";
        $e{$class} = $objs->Count;
        $e{total} += $e{$class};
        print "\r", " "x60, "\r";
    }

    return %e;
}


{
    my $last_time;
    my $start;
    my $left;
    sub progress {
        my $obj = shift;
        my $now = Time::HiRes::time();
        return if defined $last_time and $now - $last_time <= 3;

        $start = $now unless $start;
        $last_time = $now;

        my $elapsed = $now - $start;

        print `clear`;
        my ($cols, $rows) = (80, 25);
        eval {
            require Term::ReadKey;
            ($cols, $rows) = Term::ReadKey::GetTerminalSize();
        };
        $cols -= 1;

        if ($gnuplot) {
            my $length = $walker->StackSize;
            my $file = $walker->Directory . "/progress.plot";
            open(my $dat, ">>", $file);
            printf $dat "%10.3f\t%8d\n",
                $elapsed,
                $length;
            close $dat;

            if ($rows <= 24) {
                print "\n\n";
            } elsif ($elapsed) {
                system("gnuplot", "-e", <<EOT );
set term dumb $cols @{[$rows - 15]};
set xlabel "Seconds";
unset key;
set autoscale;
set title "Queue length";
plot "$file" using 1:2 with lines
EOT
            } else {
                print "\n" for 1..($rows - 14);
            }
        } else {
            print "\n\n";
        }

        my %counts = $walker->ObjectCount;
        # Just show the big ones
        for my $class (map {"RT::$_"} qw/Ticket Transaction Attachment User Group/) {
            my $display = $class;
            $display =~ s/^RT::(.*)/@{[$1]}s:/;

            $counts{$class} ||= 0;
            my $fraction = $counts{$class}/$estimates{$class};

            my $max_width = $cols - 30;
            my $bar_width = int($max_width * $fraction);

            printf "%20s |%-".$max_width."s|\n",
                $display, "=" x $bar_width;
        }

        {
            my $total = 0;
            $total += $_ for values %counts;
            print "\n";

            my $fraction = $total/$estimates{total};

            my $max_width = $cols - 30;
            my $bar_width = int($max_width * $fraction);

            printf "%20s |%-".$max_width."s|\n",
                "Total:", "#" x $bar_width;

            if ($fraction > 0.03) {
                if (defined $left) {
                    $left = 0.75 * $left
                          + 0.25 * ($elapsed / $fraction - $elapsed);
                } else {
                    $left = ($elapsed / $fraction - $elapsed);
                }
            }
            print "\n";
            printf "%20s %s\n", "Elapsed time:",
                format_time($elapsed);
            printf "%20s %s\n", "Estimated left:",
                (defined $left) ? format_time($left) : "-";
        }

        print "\n$msg";
        $msg = "";
    }
}

sub format_time {
    my $time = shift;
    my $s = "";

    $s .= int($time/60/60)."hr "
        if $time > 60*60;
    $s .= int(($time % (60*60))/60)."min "
        if $time > 60;
    $s .= int($time % 60)."s"
        if $time < 60*60;

    return $s;
}
