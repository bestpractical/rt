%# BEGIN BPS TAGGED BLOCK {{{
%#
%# COPYRIGHT:
%#
%# This software is Copyright (c) 1996-2019 Best Practical Solutions, LLC
%#                                          <sales@bestpractical.com>
%#
%# (Except where explicitly superseded by other copyright notices)
%#
%#
%# LICENSE:
%#
%# This work is made available to you under the terms of Version 2 of
%# the GNU General Public License. A copy of that license should have
%# been provided with this software, but in any event can be snarfed
%# from www.gnu.org.
%#
%# This work is distributed in the hope that it will be useful, but
%# WITHOUT ANY WARRANTY; without even the implied warranty of
%# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%# General Public License for more details.
%#
%# You should have received a copy of the GNU General Public License
%# along with this program; if not, write to the Free Software
%# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
%# 02110-1301 or visit their web page on the internet at
%# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html.
%#
%#
%# CONTRIBUTION SUBMISSION POLICY:
%#
%# (The following paragraph is not intended to limit the rights granted
%# to you to modify and distribute this software under the terms of
%# the GNU General Public License and is only of importance to you if
%# you choose to contribute your changes and enhancements to the
%# community by submitting them to Best Practical Solutions, LLC.)
%#
%# By intentionally submitting any modifications, corrections or
%# derivatives to this work, or any other work intended for use with
%# Request Tracker, to Best Practical Solutions, LLC, you confirm that
%# you are the copyright holder for those contributions and you grant
%# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,
%# royalty-free, perpetual, license to use, copy, create derivative
%# works based on those contributions, and sublicense and distribute
%# those contributions and any derivatives thereof.
%#
%# END BPS TAGGED BLOCK }}}
<& /Elements/Header, Title => loc('Custom Date Ranges') &>
<& /Elements/Tabs &>

<& /Elements/ListActions, actions => \@results &>

<&|/Widgets/TitleBox, title => loc('Custom Date Ranges In Config Files'), class => 'mx-auto max-width-xl' &>
% if ( $config && keys %{$config->{'RT::Ticket'}} ) {
<div class="table-responsive">
  <table class="table collection-as-table">
    <tr class="collection-as-table">
      <th class="collection-as-table"><&|/l&>Name</&></th>
      <th class="collection-as-table"><&|/l&>From</&></th>
      <th class="collection-as-table"><&|/l&>From Value if Unset</&></th>
      <th class="collection-as-table"><&|/l&>To</&></th>
      <th class="collection-as-table"><&|/l&>To Value if Unset</&></th>
      <th class="collection-as-table"><&|/l&>Business Hours?</&></th>
    </tr>
% my $i = 0;
% for my $name ( sort keys %{$config->{'RT::Ticket'}} ) {
% $i++;
    <tr class="collection-as-table">
      <td class="collection-as-table"><% $name %></td>
%     my $spec = $config->{'RT::Ticket'}{$name};
%     my %date_range_spec = RT::Ticket->_ParseCustomDateRangeSpec($name, $spec);
      <td class="collection-as-table"><% $date_range_spec{from} %></td>
      <td class="collection-as-table"><% $date_range_spec{from_fallback} || '' %></td>
      <td class="collection-as-table"><% $date_range_spec{to} %></td>
      <td class="collection-as-table"><% $date_range_spec{to_fallback} || '' %></td>
      <td class="collection-as-table"><% $date_range_spec{business_time} ? loc('Yes') : loc('No') %></td>
    </tr>
% }
  </table>
</div>
% }
% else {
  <p class="mt-3 mt-1 ml-3"><&|/l&>No custom date ranges in config files</&></p>
% }
</&>

<form name="CustomDateRanges" method="POST" method="?">
  <&|/Widgets/TitleBox, title => loc('Custom Date Ranges'), class => 'mx-auto max-width-xl' &>
%# TODO selectpicker options exceeding the table are invisible in .table-responsive
%# <div class="table-responsive">
  <div>
    <table class="collection-as-table table">
      <tr class="collection-as-table text-center">
        <th class="collection-as-table"><&|/l&>Name</&></th>
        <th class="collection-as-table"><&|/l&>From</&></th>
        <th class="collection-as-table"><&|/l&>From Value if Unset</&></th>
        <th class="collection-as-table"><&|/l&>To</&></th>
        <th class="collection-as-table"><&|/l&>To Value if Unset</&></th>
        <th class="collection-as-table"><&|/l&>Business Hours?</&></th>
        <th class="collection-as-table text-left">
          <input type="checkbox" name="DeleteAll" value="1" onclick="setCheckbox(this, /^\d+-Delete$/)" />
          <&|/l&>Delete</&>
        </th>
      </tr>
% my $i = 0;
% if ( $content ) {
% my $id = 0;
%   for my $name ( sort keys %{$content->{'RT::Ticket'}} ) {
% $i++;
      <tr class="collection-as-table">
        <td class="collection-as-table"><input type="text" name="<% $id %>-name" value="<% $name %>" class="form-control" /></td>
%       my %date_range_spec = RT::Ticket->_ParseCustomDateRangeSpec($name, $content->{'RT::Ticket'}{$name});
        <td class="collection-as-table"><& /Elements/SelectCustomDateRangeField, Name => "$id-from", Default => $date_range_spec{from} &></td>
        <td class="collection-as-table"><& /Elements/SelectCustomDateRangeField, Name => "$id-from_fallback", Default => $date_range_spec{from_fallback} &></td>
        <td class="collection-as-table"><& /Elements/SelectCustomDateRangeField, Name => "$id-to", Default => $date_range_spec{to} &></td>
        <td class="collection-as-table"><& /Elements/SelectCustomDateRangeField, Name => "$id-to_fallback", Default => $date_range_spec{to_fallback} &></td>
        <td class="collection-as-table">
          <select name="<% $id %>-business_time" class="form-control selectpicker">
            <option value="1" <% $date_range_spec{business_time} ? 'selected="selected"' : '' |n%>><&|/l&>Yes</&></option>
            <option value="0" <% $date_range_spec{business_time} ? '': 'selected="selected"' |n%>><&|/l&>No</&></option>
          </select>
        </td>
        <td class="collection-as-table"><input type="checkbox" name="<% $id %>-Delete" value="1" /></td>
      </tr>
%     $id++;
%   }
% }

% for ( 1 .. 3 ) {
% $i++;
      <tr class="collection-as-table">
        <td class="collection-as-table"><input type="text" name="name" value="" class="form-control" /></td>
        <td class="collection-as-table"><& /Elements/SelectCustomDateRangeField, Name => 'from' &></td>
        <td class="collection-as-table"><& /Elements/SelectCustomDateRangeField, Name => 'from_fallback' &></td>
        <td class="collection-as-table"><& /Elements/SelectCustomDateRangeField, Name => 'to' &></td>
        <td class="collection-as-table"><& /Elements/SelectCustomDateRangeField, Name => 'to_fallback' &></td>
        <td class="collection-as-table">
          <select name="business_time" class="form-control selectpicker">
            <option value="1"><&|/l&>Yes</&></option>
            <option value="0" selected="selected"><&|/l&>No</&></option>
          </select>
        </td>
        <td class="collection-as-table"></td>
      </tr>
% }
    </table>
  </div>
    <& /Elements/Submit, Name => 'Save', Label => loc('Save Changes') &>
  </&>
</form>

<%INIT>

Abort(loc("Permission Denied")) unless $session{'CurrentUser'}->HasRight( Object=> RT->System, Right => 'SuperUser');

my $config = RT->Config->Get('CustomDateRanges');
my $attribute = RT->System->FirstAttribute('CustomDateRanges') || RT::Attribute->new( $session{CurrentUser} );

my $content;

$content = $attribute->Content if $attribute->id;

my @results;

if ($Save) {
    my %label = (
        from => 'From', # loc
        to => 'To', # loc
        from_fallback => 'From Value if Unset', # loc
        to_fallback => 'To Value if Unset', # loc
    );

    my $need_save;
    if ($content) {
        my @current_names = sort keys %{ $content->{'RT::Ticket'} };
        for my $id ( 0 .. $#current_names ) {
            my $current_name = $current_names[$id];
            my $spec         = $content->{'RT::Ticket'}{$current_name};
            my $name         = $ARGS{"$id-name"};

            if ( $config && $config->{'RT::Ticket'}{$name} ) {
                push @results, loc( "[_1] already exists", $name );
                next;
            }

            if ( $ARGS{"$id-Delete"} ) {
                delete $content->{'RT::Ticket'}{$current_name};
                push @results, loc( 'Deleted [_1]', $current_name );
                $need_save ||= 1;
                next;
            }

            my $updated;
            for my $field (qw/from from_fallback to to_fallback/) {
                next if ( $spec->{$field} // '' ) eq $ARGS{"$id-$field"};
                if ((   $ARGS{"$id-$field"}
                        && RT::Ticket->_ParseCustomDateRangeSpec( $name, join ' - ', 'now', $ARGS{"$id-$field"} )
                    )
                    || ( !$ARGS{"$id-$field"} && $field =~ /fallback/ )
                  )
                {
                    $spec->{$field} = $ARGS{"$id-$field"};
                    $updated ||= 1;
                }
                else {
                    push @results, loc( 'Invalid [_1] for [_2]', loc( $label{$field} ), $name );
                    next;
                }
            }

            if ( $spec->{business_time} != $ARGS{"$id-business_time"} ) {
                $spec->{business_time} = $ARGS{"$id-business_time"};
                $updated ||= 1;
            }

            $content->{'RT::Ticket'}{$name} = $spec;
            if ( $name ne $current_name ) {
                delete $content->{'RT::Ticket'}{$current_name};
                $updated   ||= 1;
            }

            if ( $updated ) {
                push @results, loc( 'Updated [_1]', $name );
                $need_save ||= 1;
            }
        }
    }

    if ( $ARGS{name} ) {
        for my $field (qw/from from_fallback to to_fallback business_time/) {
            $ARGS{$field} = [ $ARGS{$field} ] unless ref $ARGS{$field};
        }

        my $i = 0;
        for my $name ( @{ $ARGS{name} } ) {
            if ($name) {
                if ( $config && $config->{'RT::Ticket'}{$name} || $content && $content->{'RT::Ticket'}{$name} ) {
                    push @results, loc( "[_1] already exists", $name );
                    $i++;
                    next;
                }
            }
            else {
                $i++;
                next;
            }

            my $spec = { business_time => $ARGS{business_time}[$i] };
            for my $field ( qw/from from_fallback to to_fallback/ ) {
                if ( ($ARGS{$field}[$i] && RT::Ticket->_ParseCustomDateRangeSpec( $name, join ' - ', 'now', $ARGS{$field}[$i] ))
                    || ( !$ARGS{$field}[$i] && $field =~ /fallback/  )
                ) {
                    $spec->{$field} = $ARGS{$field}[$i];
                }
                else {
                    push @results, loc( 'Invalid [_1] for [_2]', loc($field), $name );
                    $i++;
                    next;
                }
            }

            $content->{'RT::Ticket'}{$name} = $spec;
            push @results, loc( 'Created [_1]', $name );
            $need_save ||= 1;
            $i++;
        }
    }

    if ($need_save) {
        my ( $ret, $msg );
        if ( $attribute->id ) {
            ( $ret, $msg ) = $attribute->SetContent($content);
        }
        else {
            ( $ret, $msg )
              = $attribute->Create( Name => 'CustomDateRanges', Object => RT->System, Content => $content );
        }

        unless ($ret) {
            RT->Logger->error("Couldn't save content: $msg");
            push @results, $msg;
        }
    }
}

MaybeRedirectForResults(
    Actions => \@results,
    Path    => '/Search/CustomDateRanges.html',
);

</%INIT>

<%ARGS>
$Save => undef
</%ARGS>
