%# BEGIN BPS TAGGED BLOCK {{{
%#
%# COPYRIGHT:
%#
%# This software is Copyright (c) 1996-2012 Best Practical Solutions, LLC
%#                                          <sales@bestpractical.com>
%#
%# (Except where explicitly superseded by other copyright notices)
%#
%#
%# LICENSE:
%#
%# This work is made available to you under the terms of Version 2 of
%# the GNU General Public License. A copy of that license should have
%# been provided with this software, but in any event can be snarfed
%# from www.gnu.org.
%#
%# This work is distributed in the hope that it will be useful, but
%# WITHOUT ANY WARRANTY; without even the implied warranty of
%# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%# General Public License for more details.
%#
%# You should have received a copy of the GNU General Public License
%# along with this program; if not, write to the Free Software
%# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
%# 02110-1301 or visit their web page on the internet at
%# http://www.gnu.org/licenses/old-licenses/gpl-2.0.html.
%#
%#
%# CONTRIBUTION SUBMISSION POLICY:
%#
%# (The following paragraph is not intended to limit the rights granted
%# to you to modify and distribute this software under the terms of
%# the GNU General Public License and is only of importance to you if
%# you choose to contribute your changes and enhancements to the
%# community by submitting them to Best Practical Solutions, LLC.)
%#
%# By intentionally submitting any modifications, corrections or
%# derivatives to this work, or any other work intended for use with
%# Request Tracker, to Best Practical Solutions, LLC, you confirm that
%# you are the copyright holder for those contributions and you grant
%# Best Practical Solutions,  LLC a nonexclusive, worldwide, irrevocable,
%# royalty-free, perpetual, license to use, copy, create derivative
%# works based on those contributions, and sublicense and distribute
%# those contributions and any derivatives thereof.
%#
%# END BPS TAGGED BLOCK }}}
<%INIT>
$queues ||= RT::Queues->new( $session{'CurrentUser'} );
$queues->UnLimit unless $queues->_isLimited;

$m->callback( CallbackName => 'SQLFilter', Queues => $queues );

my @queues = $queue_filter
    ? grep $queue_filter->($_), @{ $queues->ItemsArrayRef }
    : @{ $queues->ItemsArrayRef }
;
$m->callback( CallbackName => 'Filter', Queues => \@queues );

$preference = $preference
    ? $session{'CurrentUser'}->UserObj->Preferences($preference, {})
    : {}
;

my $comp = '/Elements/QueueSummaryByStatus';
if ( $preference->{'SplitByLifecycle'} ) {
    $comp = '/Elements/QueueSummaryByLifecycle';
}
if ( $preference->{'Unwanted'} && keys %{ $preference->{'Unwanted'} } ) {
    @queues = grep !$preference->{'Unwanted'}{ $_->Name }, @queues;
}

return $m->comp( $comp ) unless @queues;

my %lifecycle = map { lc $_->Name => $_ } map $_->LifecycleObj, @queues;

unless (@statuses) {
    my %seen;
    foreach my $set ( 'initial', 'active' ) {
        foreach my $lifecycle ( map $lifecycle{$_}, sort keys %lifecycle ) {
            push @statuses, grep !$seen{ lc $_ }++, $lifecycle->Valid($set);
        }
    }
}

use RT::Report::Tickets;
my $report = RT::Report::Tickets->new( RT->SystemUser );
my $query =
    '('. join(" OR ", map "Status = ". RT::SQL->Quote($_), @statuses) .')'
    .' AND ('. join(' OR ', map "Queue = ". $_->id, @queues) .')';
$report->SetupGroupings( Query => $query, GroupBy => [qw(Status Queue)] );

my (%data, %data_has_status);
while ( my $entry = $report->Next ) {
    my ($queue, $status, $count) = map $entry->__Value($_), qw(Queue Status id);

    $data{ $queue }{ $status } = $count;
    $data{ $queue }{''} += $count;
    $data_has_status{ $status } = 1;
}

unless ( $preference->{'ShowEmptyColumns'} ) {
    @statuses = grep $data_has_status{$_}, @statuses;
}
unless ( $preference->{'ShowEmptyRows'} ) {
    @queues = grep $data{ $_->id }{''}, @queues;
}

my $build_search_link = sub {
    my ($queue_name, $extra_query) = @_;

    return RT->Config->Get('WebPath')
         . "/Search/Results.html?Query="
         . $m->interp->apply_escapes("Queue = ". RT::SQL->Quote($queue_name) ." AND $extra_query", 'u');
};

my $link_all = sub {
    my ($queue, $all_statuses) = @_;
    return $build_search_link->(
        $queue->Name,
        "(".join(" OR ", map "Status = ". RT::SQL->Quote($_), @$all_statuses).")"
    );
};

my $link_status = sub {
    my ($queue, $status) = @_;
    return $build_search_link->($queue->Name, "Status = ". RT::SQL->Quote($status));
};

$m->callback(
    CallbackName        => 'LinkBuilders',
    build_search_link   => \$build_search_link,
    link_all            => \$link_all,
    link_status         => \$link_status,
);

return $m->comp(
    $comp,
    queues   => \@queues,
    statuses => \@statuses,
    data     => \%data,
    linker => {
        all => $link_all,
        status => $link_status,
        search => $build_search_link,
    },
);
</%INIT>
<%ARGS>
$queues => undef
$queue_filter => undef
$preference => undef,
@statuses => ()
</%ARGS>
